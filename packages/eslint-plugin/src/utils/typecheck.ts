import type { TSESTree } from "@typescript-eslint/utils";
import { AST_NODE_TYPES } from "@typescript-eslint/utils";
import type { Type, TypeChecker } from "typescript";
import { TypeFlags } from "typescript";
import type { RuleContext } from "@typescript-eslint/utils/ts-eslint";

export const isObjectLikeKeyword = (node: TSESTree.TypeNode): boolean =>
  objectLikeKeywords.some((k) => k === node.type);

const objectLikeKeywords = [
  AST_NODE_TYPES.TSAbstractKeyword,
  AST_NODE_TYPES.TSAnyKeyword,
  // AST_NODE_TYPES.TSArrayType,
  AST_NODE_TYPES.TSAsyncKeyword,
  // AST_NODE_TYPES.TSBigIntKeyword,
  // AST_NODE_TYPES.TSBooleanKeyword,
  AST_NODE_TYPES.TSConditionalType,
  AST_NODE_TYPES.TSConstructorType,
  AST_NODE_TYPES.TSDeclareKeyword,
  AST_NODE_TYPES.TSExportKeyword,
  AST_NODE_TYPES.TSFunctionType,
  AST_NODE_TYPES.TSImportType,
  AST_NODE_TYPES.TSIndexedAccessType,
  AST_NODE_TYPES.TSInferType,
  AST_NODE_TYPES.TSIntersectionType,
  AST_NODE_TYPES.TSIntrinsicKeyword,
  // AST_NODE_TYPES.TSLiteralType,
  AST_NODE_TYPES.TSMappedType,
  AST_NODE_TYPES.TSNamedTupleMember,
  AST_NODE_TYPES.TSNeverKeyword,
  AST_NODE_TYPES.TSNullKeyword,
  // AST_NODE_TYPES.TSNumberKeyword,
  AST_NODE_TYPES.TSObjectKeyword,
  AST_NODE_TYPES.TSOptionalType,
  AST_NODE_TYPES.TSPrivateKeyword,
  AST_NODE_TYPES.TSProtectedKeyword,
  AST_NODE_TYPES.TSPublicKeyword,
  AST_NODE_TYPES.TSQualifiedName,
  AST_NODE_TYPES.TSReadonlyKeyword,
  AST_NODE_TYPES.TSRestType,
  AST_NODE_TYPES.TSStaticKeyword,
  // AST_NODE_TYPES.TSStringKeyword,
  AST_NODE_TYPES.TSSymbolKeyword,
  AST_NODE_TYPES.TSTemplateLiteralType,
  AST_NODE_TYPES.TSThisType,
  AST_NODE_TYPES.TSTupleType,
  AST_NODE_TYPES.TSTypeLiteral,
  AST_NODE_TYPES.TSTypeOperator,
  AST_NODE_TYPES.TSTypePredicate,
  AST_NODE_TYPES.TSTypeQuery,
  AST_NODE_TYPES.TSTypeReference,
  AST_NODE_TYPES.TSUndefinedKeyword,
  AST_NODE_TYPES.TSUnionType,
  AST_NODE_TYPES.TSUnknownKeyword,
  AST_NODE_TYPES.TSVoidKeyword,
] satisfies Array<TSESTree.TypeNode["type"]>;

export const isObjectLikeType = (type: Type): boolean =>
  objectLikeTypeFlags.some((f) => (type.flags & f) > 0);

const objectLikeTypeFlags = [
  // TypeFlags.Any,
  // TypeFlags.Unknown,
  // TypeFlags.String,
  // TypeFlags.Number,
  // TypeFlags.Boolean,
  // TypeFlags.Enum,
  // TypeFlags.BigInt,
  // TypeFlags.StringLiteral,
  // TypeFlags.NumberLiteral,
  // TypeFlags.BooleanLiteral,
  // TypeFlags.EnumLiteral,
  // TypeFlags.BigIntLiteral,
  // TypeFlags.ESSymbol,
  // TypeFlags.UniqueESSymbol,
  TypeFlags.Void,
  TypeFlags.Undefined,
  TypeFlags.Null,
  // TypeFlags.Never,
  TypeFlags.TypeParameter,
  TypeFlags.Object,
  // TypeFlags.Union,
  // TypeFlags.Intersection,
  // TypeFlags.Index,
  // TypeFlags.IndexedAccess,
  // TypeFlags.Conditional,
  // TypeFlags.Substitution,
  // TypeFlags.NonPrimitive,
  // TypeFlags.TemplateLiteral,
  // TypeFlags.StringMapping,
  // TypeFlags.Literal,
  // TypeFlags.Unit,
  // TypeFlags.Freshable,
  // TypeFlags.StringOrNumberLiteral,
  // TypeFlags.PossiblyFalsy,
  // TypeFlags.StringLike,
  // TypeFlags.NumberLike,
  // TypeFlags.BigIntLike,
  // TypeFlags.BooleanLike,
  // TypeFlags.EnumLike,
  // TypeFlags.ESSymbolLike,
  // TypeFlags.VoidLike,
  // TypeFlags.UnionOrIntersection,
  // TypeFlags.StructuredType,
  // TypeFlags.TypeVariable,
  // TypeFlags.InstantiableNonPrimitive,
  // TypeFlags.InstantiablePrimitive,
  // TypeFlags.Instantiable,
  // TypeFlags.StructuredOrInstantiable,
  // TypeFlags.Narrowable,
];

export const createTypeChecker = <
  MessageIds extends string,
  Options extends readonly unknown[],
>(
  context: RuleContext<MessageIds, Options>,
): TypeChecker | undefined =>
  context.sourceCode.parserServices?.program?.getTypeChecker();
